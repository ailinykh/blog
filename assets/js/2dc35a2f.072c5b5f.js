"use strict";(self.webpackChunkailinykh_com=self.webpackChunkailinykh_com||[]).push([[681],{2841:e=>{e.exports=JSON.parse('{"permalink":"/dependency-inversion-principle","editUrl":"https://github.com/ailinykh/blog/edit/master/blog/2021-02-16-dependency-inversion-principle.md","source":"@site/blog/2021-02-16-dependency-inversion-principle.md","title":"Dependency Inversion Principle","description":"The Dependency Inversion Principle is the last one from SOLID stands for decoupling the system into independent modules. It means that one part of a system should not depend on another one directly.","date":"2021-02-16T00:00:00.000Z","tags":[{"inline":true,"label":"swift","permalink":"/tags/swift"},{"inline":true,"label":"SOLID","permalink":"/tags/solid"},{"inline":true,"label":"dependency inversion","permalink":"/tags/dependency-inversion"},{"inline":true,"label":"architecture","permalink":"/tags/architecture"},{"inline":true,"label":"ios","permalink":"/tags/ios"}],"readingTime":2.08,"hasTruncateMarker":true,"authors":[{"name":"Anton Ilinykh","title":"Software Engineer","imageURL":"https://avatars.githubusercontent.com/u/939390?s=400&v=4","key":"anton","page":null}],"frontMatter":{"slug":"dependency-inversion-principle","title":"Dependency Inversion Principle","authors":["anton"],"tags":["swift","SOLID","dependency inversion","architecture","ios"]},"unlisted":false,"prevItem":{"title":"Testing netwok requests with URLProtocol stubs","permalink":"/network-testing-with-url-protocol-stubbing"}}')},5663:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>a,contentTitle:()=>l,default:()=>h,frontMatter:()=>s,metadata:()=>i,toc:()=>d});var i=t(2841),o=t(4848),r=t(8453);const s={slug:"dependency-inversion-principle",title:"Dependency Inversion Principle",authors:["anton"],tags:["swift","SOLID","dependency inversion","architecture","ios"]},l=void 0,a={authorsImageUrls:[void 0]},d=[{value:"Solution",id:"solution",level:2}];function c(e){const n={a:"a",code:"code",em:"em",h2:"h2",mermaid:"mermaid",p:"p",pre:"pre",strong:"strong",...(0,r.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsxs)(n.p,{children:["The Dependency Inversion Principle is the last one from ",(0,o.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/SOLID",children:"SOLID"})," stands for decoupling the system into independent modules. It means that one part of a system should not depend on another one directly."]}),"\n",(0,o.jsx)(n.p,{children:"Let's see an example."}),"\n",(0,o.jsxs)(n.p,{children:["On the one hand, we have a ",(0,o.jsx)(n.code,{children:"ViewController"})," which is the part of ",(0,o.jsx)(n.em,{children:"UI/Presentation Module"}),", and on the other hand, we have some data source which can be a part of ",(0,o.jsx)(n.em,{children:"Networking/Persistence Module"}),". Let's say it is an ",(0,o.jsx)(n.code,{children:"URLSession"})," object."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-swift",children:"class ViewController: UIViewController {\n\n    override func viewDidLoad() {\n        super.viewDidLoad()\n\n        URLSession.shared.dataTask(with: url) { data, response, error in\n            // Do something with response\n        }.resume()\n    }\n\n}\n"})}),"\n",(0,o.jsx)("br",{}),"\n",(0,o.jsx)(n.p,{children:"This code can be represented by a diagram"}),"\n",(0,o.jsx)("div",{style:{textAlign:"center"},children:(0,o.jsx)(n.mermaid,{value:"flowchart LR\n    ViewController --\x3e URLSession\n\n    subgraph UI Module\n        ViewController\n    end\n\n    subgraph Networking Module\n        URLSession\n    end\n"})}),"\n",(0,o.jsxs)(n.p,{children:["The ",(0,o.jsx)(n.code,{children:"UIViewController"})," depends on ",(0,o.jsx)(n.code,{children:"URLSession"})," concrete implementation. And it means that ",(0,o.jsx)(n.code,{children:"URLSession"})," ",(0,o.jsx)(n.strong,{children:"can't"})," be replaced with another ",(0,o.jsx)(n.em,{children:"Network"})," client such as ",(0,o.jsx)(n.a,{href:"https://github.com/Alamofire/Alamofire",children:"Alamofire"})," without changing the ",(0,o.jsx)(n.em,{children:"Presentation Module"}),"."]}),"\n",(0,o.jsx)(n.h2,{id:"solution",children:"Solution"}),"\n",(0,o.jsxs)(n.p,{children:["This problem can be solved with Dependency Inversion just by adding another abstraction between concrete implementations. Some ",(0,o.jsx)(n.code,{children:"protocol"})," that can live in ",(0,o.jsx)(n.em,{children:"Presentation Module"})," and the ",(0,o.jsx)(n.em,{children:"Network Module"})," can conform to it."]}),"\n",(0,o.jsx)("div",{style:{textAlign:"center"},children:(0,o.jsx)(n.mermaid,{value:'flowchart LR\n    ViewController --\x3e HTTPClient["&lt;HTTPClient&gt;"]\n    URLSession -.-> HTTPClient\n\n    subgraph UI Module\n        ViewController\n        HTTPClient\n    end\n\n    subgraph Networking Module\n        URLSession\n    end\n'})}),"\n",(0,o.jsx)(n.p,{children:"and the code above will transform to"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-swift",children:"protocol HTTPClient {\n    func load(url: URL, completion: @escaping (Data?, URLResponse?, Error?) -> Void)\n}\n\nclass ViewController: UIViewController {\n\n    var client: HTTPClient!\n\n    override func viewDidLoad() {\n        super.viewDidLoad()\n\n        client.load(url: url) { (data, response, error) in\n            // Do something\n        }\n    }\n}\n"})}),"\n",(0,o.jsxs)(n.p,{children:["Now you can have two separate implementations of ",(0,o.jsx)(n.code,{children:"HTTPClient"})," protocol, and they both can live in ",(0,o.jsx)(n.em,{children:"Network Module"})]}),"\n",(0,o.jsx)("div",{style:{textAlign:"center"},children:(0,o.jsx)(n.mermaid,{value:'flowchart LR\n    ViewController --\x3e HTTPClient["&lt;HTTPClient&gt;"]\n    HTTPURLSession --\x3e URLSession\n    HTTPAlamofire --\x3e Alamofire\n    HTTPURLSession -.-> HTTPClient\n    HTTPAlamofire -.-> HTTPClient\n\n    subgraph Networking Module\n        HTTPURLSession\n        URLSession\n        HTTPAlamofire\n        Alamofire\n    end\n\n    subgraph UI Module\n        ViewController\n        HTTPClient\n    end\n'})}),"\n",(0,o.jsxs)(n.p,{children:["That's the way you invert the dependencies from one module to another, and now you can easily switch between two concrete implementations of ",(0,o.jsx)(n.code,{children:"HTTPClient"})," from ",(0,o.jsx)(n.em,{children:"Networking Module"}),"."]})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(c,{...e})}):c(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>l});var i=t(6540);const o={},r=i.createContext(o);function s(e){const n=i.useContext(r);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:s(e.components),i.createElement(r.Provider,{value:n},e.children)}}}]);